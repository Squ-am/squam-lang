// Comprehensive test of implemented features

struct Point {
    x: i64,
    y: i64,
}

impl Point {
    fn new(x: i64, y: i64) -> Point {
        Point { x, y }
    }

    fn sum(self) -> i64 {
        self.x + self.y
    }

    fn scale(self, factor: i64) -> Point {
        Point { x: self.x * factor, y: self.y * factor }
    }
}

fn main() {
    println("=== Range Iteration ===");

    // Exclusive range
    println("0..5:");
    for i in 0..5 {
        println(i);
    }

    // Inclusive range
    println("0..=3:");
    for i in 0..=3 {
        println(i);
    }

    println("=== Structs ===");

    // Struct creation
    let p = Point { x: 10, y: 20 };
    println(p.x);
    println(p.y);

    // Shorthand field syntax
    let x = 100;
    let y = 200;
    let p2 = Point { x, y };
    println(p2.x);

    // Field assignment
    p.x = 999;
    println(p.x);

    println("=== Methods ===");

    // Static method call
    let p3 = Point::new(3, 4);
    println(p3.sum());

    // Method that returns struct
    let p4 = p3.scale(2);
    println(p4.x);
    println(p4.y);

    println("=== Match ===");

    // Match on literal
    let n = 42;
    match n {
        0 => println("zero"),
        42 => println("forty-two"),
        _ => println("other"),
    }

    // Wildcard pattern
    let num = 100;
    match num {
        _ => println("matched wildcard"),
    }

    println("=== Closures ===");

    // Simple closure
    let add = |a, b| a + b;
    println(add(3, 4));

    // Closure capturing a variable
    let factor = 10;
    let multiply = |x| x * factor;
    println(multiply(5));

    // Closure that reads captured variable twice
    let value = 100;
    let get_double = || value + value;
    println(get_double());

    println("=== Destructuring ===");

    // First let's see if tuples work
    let pair = (10, 20);
    println(pair);  // Should print (10, 20)

    // Now try destructuring
    let (a, b) = (30, 40);
    println(a);
    println(b);

    println("=== Complete ===");
}
